# RxTraceNetCap 使用指南

## 一、项目概述

RxTraceNetCap 是一个基于 HTTP 服务的网络抓包管理系统，它基于 libpcap 库实现高性能数据包捕获，提供了便捷的 RESTful API 接口和命令行工具，用于自动化网络流量采集、监控和故障诊断。

系统主要服务于生产环境中的网络流量分析需求，支持按网卡、进程、PID 等多种方式触发抓包，具备自动压缩、清理、归档等运维功能，并能根据系统资源使用情况（CPU、内存、网络流量）自动触发抓包任务。

### 核心特性

- **多种抓包模式**：支持按网卡接口、进程名、进程 PID、容器等多种方式抓包
- **HTTP API 接口**：提供 RESTful 风格的 HTTP 接口，便于集成到自动化运维系统
- **命令行工具**：提供 `rxcli` 命令行客户端，支持批量提交抓包任务
- **自动化策略**：可根据 CPU、内存、网络流量等指标自动触发抓包
- **文件管理**：自动压缩、归档和清理抓包文件，支持设置保留时间和空间限制
- **并发控制**：支持多个抓包任务并发执行，可配置最大并发数
- **热重载配置**：支持在运行时重新加载策略配置，无需重启服务

---

## 二、配置文件详解

### 2.1 主配置文件 (rxtracenetcap.ini)

主配置文件位于 `config/rxtracenetcap.ini`，用于配置服务器运行参数和路径信息。

```ini
[server]
bind_addr=0.0.0.0          # HTTP 服务绑定地址，0.0.0.0 表示监听所有网卡
port=8080                  # HTTP 服务端口号
workers=2                  # HTTP 工作线程数量
capture_threads=4          # 抓包工作线程数量
post_workers=1             # 后处理工作线程数量

strategy_path = ./config/strategy.ini  # 策略配置文件路径

[logging]
log_config_path = ./config/log.conf    # 日志配置文件路径
```

**参数说明：**

- **bind_addr**：HTTP 服务监听的 IP 地址
  - `0.0.0.0`：监听所有网络接口
  - `127.0.0.1`：仅本地访问
  - 特定 IP：只监听指定网卡

- **port**：HTTP 服务端口号（默认 8080）
  - 可根据环境修改，避免端口冲突
  - 需要确保防火墙允许该端口访问

- **workers**：HTTP 处理线程数量
  - 默认 2 个，用于并发处理 HTTP 请求
  - 可根据并发量调整

- **capture_threads**：抓包工作线程数量
  - 默认 4 个，决定了系统最多同时执行的抓包任务数
  - 每个线程独立执行一个抓包任务

- **post_workers**：后处理线程数量
  - 用于处理抓包完成后的文件压缩、归档等操作

### 2.2 策略配置文件 (strategy.ini)

策略配置文件位于 `config/strategy.ini`，包含抓包策略、存储策略、自动触发规则等，**支持热重载**。

#### 2.2.1 服务器运行参数

```ini
[server]
sample_interval_sec = 1              # 系统采样间隔（秒），采集 CPU、内存、网络流量
batch_compress_interval_sec = 300    # 批量压缩检查间隔（秒）
queue_timer_interval_ms = 50         # 消息队列处理间隔（毫秒）
```

#### 2.2.2 抓包默认参数

```ini
[capture]
default_interface = any              # 默认网卡接口，any 表示所有接口
default_duration = 60                # 默认抓包时长（秒）
default_category = diag              # 默认分类标签
file_pattern = {day}/{date}-{iface}-{proc}-{port}.pcap  # 输出文件命名模板
output_dir = /var/log/rxtrace/captures                  # 抓包文件输出目录
max_file_size_mb = 200               # 单个文件最大大小（MB）
```

**file_pattern 支持的占位符：**

- `{day}`：日期目录（格式：YYYYMMDD）
- `{date}`：日期时间（格式：YYYYMMDD_HHMMSS）
- `{iface}`：网卡接口名
- `{proc}`：进程名
- `{port}`：端口号
- `{pid}`：进程 PID
- `{category}`：分类标签

例如：`20231230/20231230_143500-eth0-nginx-80.pcap`

#### 2.2.3 存储管理策略

```ini
[storage]
base_dir = /var/log/rxtrace/captures  # 抓包文件基础目录
compress_enabled = true                # 是否启用压缩
compress_cmd = gzip -9                 # 压缩命令
compress_remove_src = false            # 压缩后是否删除源文件
max_age_days = 7                       # 文件最大保留天数
max_size_gb = 100                      # 最大占用空间（GB）
```

#### 2.2.4 采样监控参数

```ini
[sample]
worker_queue_size = 1024          # 工作队列大小
cpu_pct_gt = 85                   # CPU 使用率阈值（%）
mem_pct_gt = 90                   # 内存使用率阈值（%）
net_rx_kbps_gt = 8000             # 网络接收速率阈值（KB/s）
```

#### 2.2.5 自动触发规则

系统支持根据资源使用情况自动触发抓包，每个规则可配置：

**示例 1：CPU 过高自动抓包**

```ini
[sample.cpu_surged]
cpu_pct_gt = 85                   # 触发条件：CPU 使用率 > 85%
trigger_capture = iface:any       # 触发动作：在所有网卡上抓包
capture_duration_sec = 90         # 抓包时长 90 秒
cooldown_sec = 300                # 冷却时间 300 秒（5 分钟内不重复触发）
```

**示例 2：内存不足自动抓包**

```ini
[sample.memory_spike]
mem_pct_gt = 92                   # 触发条件：内存使用率 > 92%
trigger_capture = iface:any
capture_duration_sec = 60
cooldown_sec = 600
```

**示例 3：监控特定进程网络流量**

```ini
[sample.nginx_hotspot]
net_rx_kbps_gt = 12000            # 触发条件：网络接收速率 > 12000 KB/s
trigger_capture = process:nginx   # 针对 nginx 进程抓包
capture_category = auto-nginx     # 分类标签
capture_duration_sec = 120
cooldown_sec = 900
```

#### 2.2.6 清理和归档策略

```ini
[cleanup]
compress_interval_sec = 600          # 压缩检查间隔（秒）
record_dir = /var/log/rxtrace/cleanup           # 清理记录目录
record_max_size_mb = 50              # 清理记录最大大小（MB）
record_max_files = 5                 # 保留的记录文件数量
compress_threshold_mb = 1024         # 压缩阈值（MB）
archive_dir = /var/log/rxtrace/archives         # 归档目录
archive_format = tar.gz              # 归档格式
archive_keep_days = 14               # 归档文件保留天数
archive_max_total_size_mb = 0        # 归档文件总大小限制（0 表示不限制）
archive_remove_source = true         # 归档后是否删除源文件
```

#### 2.2.7 安全限制

```ini
[security]
max_concurrent_captures = 10      # 最大并发抓包任务数
```

### 2.3 日志配置文件 (log.conf)

```ini
[logging]
log_path = logs/rxtracenetcap.log   # 日志文件路径
log_prefix = rxtrace                # 日志文件前缀
log_size_mb = 100                   # 单个日志文件大小（MB）
log_level = 16                      # 日志级别（数值越大越详细）
```

**日志级别说明：**
- 1: ERROR - 仅记录错误
- 4: WARNING - 记录警告和错误
- 8: INFO - 记录一般信息
- 16: DEBUG - 记录调试信息

---

## 三、命令行工具 (rxcli)

### 3.1 工具说明

`rxcli` 是配套的命令行客户端工具，用于向 `rxtracenetcap` 服务提交抓包任务。它读取 JSON 格式的任务描述文件，通过 HTTP 接口将任务提交到服务端。

### 3.2 基本用法

```bash
rxcli <tasks.json> [--host HOST] [--port PORT] [--path PATH]
```

**参数说明：**

- `<tasks.json>`：必需参数，JSON 格式的任务文件路径
- `--host HOST`：服务器地址（默认：127.0.0.1）
- `--port PORT`：服务器端口（默认：8080）
- `--path PATH`：API 路径（默认：/api/capture/start）

**示例：**

```bash
# 使用默认服务器地址和端口
rxcli cli_samples/capture_interface.json

# 指定远程服务器
rxcli cli_samples/capture_process.json --host 192.168.1.100 --port 8080

# 批量提交多个任务
rxcli cli_samples/capture_bpf.json
```

### 3.3 CLI 示例文件详解

CLI 示例文件位于 `cli_samples/` 目录，每个文件演示一种抓包场景。

#### 3.3.1 按网卡接口抓包 (capture_interface.json)

```json
[
  {
    "iface": "eth0"
  }
]
```

**说明：**
- 在指定网卡接口上抓包
- 其他参数（如抓包时长）使用配置文件中的默认值

**可选参数：**
- `duration` 或 `duration_sec`：抓包时长（秒），例如 `"duration": 120`
- `filter` 或 `bpf`：BPF 过滤表达式，例如 `"filter": "tcp port 80"`
- `file_pattern`：自定义文件命名，例如 `"file_pattern": "capture-{date}.pcap"`
- `category`：分类标签，例如 `"category": "network-debug"`

#### 3.3.2 使用 BPF 过滤器抓包 (capture_bpf.json)

```json
[
  {
    "bpf": "tcp and dst port 22"
  }
]
```

**说明：**
- 仅捕获符合 BPF 过滤条件的数据包
- 本例中只抓取目标端口为 22 的 TCP 流量（SSH 流量）
- 未指定网卡时，使用 `default_interface` 配置（默认 `any`）

**BPF 表达式示例：**
- `"tcp port 80"`：抓取 80 端口的 TCP 流量
- `"udp and host 8.8.8.8"`：抓取与 8.8.8.8 之间的 UDP 流量
- `"icmp"`：只抓取 ICMP（ping）包
- `"not port 22"`：排除 SSH 流量

#### 3.3.3 按进程名抓包 (capture_process.json)

```json
[
  {
    "proc_name": "stock_driver"
  }
]
```

**说明：**
- 根据进程名启动抓包
- 系统会查找所有名为 `stock_driver` 的进程，获取其 PID
- 通过进程的网络命名空间（network namespace）进行抓包

**适用场景：**
- 只关注特定应用的网络流量
- 进程名明确，无需手动查找 PID

#### 3.3.4 针对自身进程抓包 (capture_process_self.json)

```json
[
  {
    "proc_name": "rxtracenetcap"
  }
]
```

**说明：**
- 抓取 `rxtracenetcap` 服务自身的网络流量
- 可用于调试服务器自身的网络通信

#### 3.3.5 按进程 PID 抓包 (capture_pid.json)

```json
[
  {
    "pid": 12345
  }
]
```

**说明：**
- 直接指定进程 PID
- 适用于已知目标进程 PID 的场景
- 字段名也可以使用 `target_pid`

**注意：**
- PID 必须是当前存在的进程
- 如果进程已退出，抓包任务会失败

### 3.4 JSON 任务文件完整参数列表

一个完整的任务 JSON 可以包含以下参数：

```json
[
  {
    "iface": "eth0",                    # 网卡接口名
    "proc_name": "nginx",               # 进程名
    "pid": 12345,                       # 进程 PID（或 target_pid）
    "filter": "tcp port 80",            # BPF 过滤表达式（或 bpf）
    "duration": 120,                    # 抓包时长（秒，或 duration_sec）
    "file_pattern": "web-{date}.pcap",  # 文件命名模板
    "category": "http-debug",           # 分类标签
    "protocol": "tcp",                  # 协议过滤
    "priority": "high"                  # 优先级
  }
]
```

**参数优先级：**
1. 如果同时指定了 `proc_name` 和 `iface`，优先使用 `proc_name`
2. 如果同时指定了 `filter` 和 `bpf`，两者等价，后者覆盖前者
3. 如果同时指定了 `duration` 和 `duration_sec`，优先使用 `duration`
4. 如果同时指定了 `pid` 和 `target_pid`，优先使用 `pid`

**批量提交：**
JSON 文件可以包含多个任务对象：

```json
[
  {
    "iface": "eth0",
    "duration": 60
  },
  {
    "proc_name": "nginx",
    "filter": "tcp port 80",
    "duration": 120
  },
  {
    "pid": 12345,
    "bpf": "icmp"
  }
]
```

`rxcli` 会依次提交所有任务，并报告每个任务的执行结果。

---

## 四、HTTP API 接口

### 4.1 接口列表

服务提供以下 HTTP 接口：

| 接口路径                  | 方法   | 功能说明             |
|--------------------------|--------|---------------------|
| `/api/capture/start`     | POST   | 启动新的抓包任务     |
| `/api/capture/stop`      | POST   | 停止指定的抓包任务   |
| `/api/capture/status`    | GET    | 查询抓包任务状态     |

### 4.2 启动抓包任务 (POST /api/capture/start)

**请求示例：**

```bash
curl -X POST http://127.0.0.1:8080/api/capture/start \
  -H "Content-Type: application/json" \
  -d '{
    "iface": "eth0",
    "duration": 120,
    "filter": "tcp port 80"
  }'
```

**请求参数：**

与 `rxcli` 的 JSON 格式相同，支持的字段包括：
- `iface`：网卡接口名
- `proc_name`：进程名
- `pid` 或 `target_pid`：进程 PID
- `filter` 或 `bpf`：BPF 过滤表达式
- `duration` 或 `duration_sec`：抓包时长（秒）
- `file_pattern` 或 `file`：输出文件名模板
- `category`：分类标签
- `protocol`：协议过滤
- `priority`：优先级

**响应示例（成功）：**

```json
{
  "capture_id": 1001,
  "key": "iface:eth0:tcp port 80",
  "sid": "20231230_143500_abc123",
  "status": "pending",
  "path": "/var/log/rxtrace/captures/20231230/20231230_143500-eth0.pcap",
  "duplicate": false
}
```

**响应字段说明：**
- `capture_id`：任务唯一 ID
- `key`：任务唯一标识符
- `sid`：会话 ID
- `status`：任务状态（pending、resolving、running、completed、failed、stopped）
- `path`：输出文件路径
- `duplicate`：是否为重复任务

**响应示例（失败）：**

```json
{
  "error": "Invalid interface name"
}
```

### 4.3 停止抓包任务 (POST /api/capture/stop)

**请求示例：**

```bash
curl -X POST http://127.0.0.1:8080/api/capture/stop \
  -H "Content-Type: application/json" \
  -d '{
    "capture_id": 1001
  }'
```

**请求参数：**
- `capture_id`：要停止的任务 ID

**响应示例：**

```json
{
  "result": "ok",
  "capture_id": 1001,
  "status": "stopped"
}
```

### 4.4 查询任务状态 (GET /api/capture/status)

**请求示例：**

```bash
# 查询所有任务
curl http://127.0.0.1:8080/api/capture/status

# 查询指定任务
curl "http://127.0.0.1:8080/api/capture/status?capture_id=1001"
```

**响应示例：**

```json
{
  "tasks": [
    {
      "capture_id": 1001,
      "key": "iface:eth0:tcp port 80",
      "status": "running",
      "mode": "interface",
      "iface": "eth0",
      "filter": "tcp port 80",
      "duration_sec": 120,
      "output_file": "/var/log/rxtrace/captures/20231230/20231230_143500-eth0.pcap",
      "start_time": 1703924100,
      "packet_count": 15432,
      "bytes_captured": 8234567
    }
  ]
}
```

---

## 五、运行模式与工作流程

### 5.1 抓包模式

系统支持四种抓包模式：

#### 5.1.1 网卡接口模式 (MODE_INTERFACE)

- **描述**：直接在指定网卡接口上抓包
- **参数**：`iface`（网卡名称，如 `eth0`、`any`）
- **实现方式**：使用 `pcap_open_live()` 打开网卡接口
- **适用场景**：抓取某个网卡上的所有流量

#### 5.1.2 进程名模式 (MODE_PROCESS)

- **描述**：根据进程名查找进程，进入其网络命名空间抓包
- **参数**：`proc_name`（进程名称）
- **工作流程**：
  1. 根据进程名查找匹配的进程（通过 `/proc/*/cmdline`）
  2. 获取进程 PID
  3. 切换到进程的网络命名空间（`setns()`）
  4. 使用 libpcap 在该命名空间内抓包
- **适用场景**：只关注特定应用的网络流量

#### 5.1.3 进程 PID 模式 (MODE_PID)

- **描述**：直接指定进程 PID，进入其网络命名空间抓包
- **参数**：`pid` 或 `target_pid`
- **工作流程**：与进程名模式类似，但无需查找进程
- **适用场景**：已知目标进程 PID

#### 5.1.4 容器模式 (MODE_CONTAINER)

- **描述**：针对容器进行抓包
- **参数**：`container_id` 或 `netns_path`（网络命名空间路径）
- **适用场景**：容器化环境中的流量分析

### 5.2 任务生命周期

每个抓包任务经历以下状态：

```
[STATUS_PENDING]      # 待处理
  ↓
[STATUS_RESOLVING]    # 解析进程名/网络命名空间
  ↓
[STATUS_RUNNING]      # 正在抓包
  ↓
[STATUS_COMPLETED]    # 正常完成
  或
[STATUS_FAILED]       # 失败
  或
[STATUS_STOPPED]      # 被手动停止
```

### 5.3 完整工作流程示例

以下是一个典型的抓包任务完整流程：

1. **客户端提交任务**
   ```bash
   rxcli cli_samples/capture_process.json
   ```

2. **HTTP 服务器接收请求**
   - 解析 JSON 参数
   - 验证参数有效性
   - 生成任务 ID 和唯一标识符

3. **抓包管理线程处理请求**
   - 检查是否有相同任务正在运行（去重）
   - 如果是进程名模式，调用进程解析器查找 PID
   - 将任务加入队列
   - 选择可用的工作线程

4. **抓包执行线程启动任务**
   - 使用 libpcap 初始化抓包会话（`pcap_open_live`）
   - 设置 BPF 过滤器（如果指定）
   - 打开输出文件（`pcap_dump_open`）
   - 定期上报进度（每 2 秒）

5. **抓包进行中**
   - libpcap 持续捕获网络数据包并写入 PCAP 文件
   - 监控文件大小、包数量、时长
   - 检查是否达到停止条件（超时、文件大小限制等）

6. **抓包完成**
   - 关闭 libpcap 会话（`pcap_close`）
   - 上报最终统计信息
   - 将抓包文件路径通知清理线程

7. **文件后处理**
   - 清理线程接收文件信息
   - 根据策略决定是否压缩
   - 定期检查并清理过期文件

8. **返回结果给客户端**
   - 构造 JSON 响应
   - 返回任务 ID、状态、文件路径等信息

---

## 六、系统监控与自动化

### 6.1 系统采样机制

采样线程每隔 1 秒（可配置）采集以下系统指标：

- **CPU 使用率**：通过读取 `/proc/stat` 计算
- **内存使用率**：通过读取 `/proc/meminfo` 计算
- **网络流量**：通过读取 `/proc/net/dev` 计算接收/发送速率

### 6.2 自动触发规则

当某个指标超过配置的阈值，且满足冷却时间条件时，自动触发抓包任务。

**冷却机制**：
- 每个规则记录最后触发时间
- 在冷却期内不会重复触发
- 避免频繁创建任务，减少系统负担

**触发动作类型**：
- `iface:<接口名>`：在指定网卡上抓包
- `process:<进程名>`：针对特定进程抓包

### 6.3 文件管理与清理

系统自动管理抓包文件的生命周期：

1. **实时压缩**：抓包完成后，文件大小超过阈值时自动压缩
2. **定期归档**：将多个小文件打包成归档文件（tar.gz）
3. **过期清理**：删除超过保留期限的文件
4. **空间管理**：当存储空间超过限制时，删除最旧的文件

---

## 七、部署与运维

### 7.1 编译安装

**依赖项：**
- GCC/G++ (支持 C++98)
- libpcap 开发库
- pthread 库

**编译步骤：**

```bash
cd /home/rong/gnrx/rxtracenetcap
make clean
make all
```

编译成功后，生成以下可执行文件：
- `bin/rxtracenetcap`：主服务程序
- `bin/rxcli`：命令行客户端

### 7.2 运行服务

**前台运行（调试模式）：**

```bash
cd /home/rong/gnrx/rxtracenetcap
./bin/rxtracenetcap
```

**后台运行（生产模式）：**

```bash
nohup ./bin/rxtracenetcap > logs/server.log 2>&1 &
```

**注意事项：**
- 服务需要 root 权限（因为 libpcap 需要 CAP_NET_RAW 能力）
- 确保配置文件路径正确（相对路径为 `./config/`）
- 确保输出目录存在并有写入权限

---

## 附录

### 附录 A：文件命名占位符

| 占位符 | 说明 | 示例 |
|-------|------|------|
| {day} | 日期目录（YYYYMMDD） | 20231230 |
| {date} | 日期时间（YYYYMMDD_HHMMSS） | 20231230_143500 |
| {iface} | 网卡接口名 | eth0 |
| {proc} | 进程名 | nginx |
| {port} | 端口号 | 80 |
| {pid} | 进程 PID | 12345 |
| {category} | 分类标签 | debug |

---
